## `var` and Type Inference

### What is it?

`var` allows the compiler to **infer** the variable’s type **at compile time**, based on the initializer.
```C#
var x = 10;        // int
var name = "John"; // string
var list = new List<int>(); // List<int>
```
### Key idea:
- **Type inference happens at compile time**, not at runtime.
- After compilation, `x`, `name`, etc. have fixed, _strongly typed_ types — `int`, `string`, etc.
### Why does it matter?
- Improves readability (less redundancy).
- Still **statically typed** — no performance cost or dynamic typing involved.
- The compiler must know the type → it can’t be `null` or unknown.
### Common errors:
```C#
	var x; // no initializer to infer type from
	var y = {1, 2, 3}; // collection intializers are not permitted
	var z = null; // not permitted
```

______
## `readonly`
### What is it?
- A **field** that can only be assigned:
    - **At declaration**, or
    - **Inside a constructor**.
It ensures that once the object is constructed, the value cannot change.
```C#
class S {
	public int a;
	public readonly int b;
	public readonly int c = 7; 
	
	public S(){
		b = 8;   // ✅ allowed in constructor
        c = 10;  // ✅ allowed in constructor (overwrites initializer)
		f(); // will not work, why? bc `readonly` can only be assigned at declaration or inside a constructor
	}
	
	public void f(){
		b = 0; // ❌ compile error – readonly outside constructor
        c = 0; // ❌ compile error
	}
}
```
### Note:
- The `f()` function is independent — it’s not part of the object construction process.
- Therefore, `f()` cannot modify readonly fields.
- functions are called independently in Csharp ????
______
## Shared Value (Design Idea)

If multiple objects share the same value (e.g., `scale`),  
you can create a **shared class** that holds it.
```C#
class SharedScale {
    public double Value { get; set; }
}

class Shape {
    public SharedScale Scale { get; set; }
}
```
That way, all shapes can reference the same `SharedScale` instance — changing one changes all.
______
# Auto-Implemented Properties
### Example 1 – Simplified syntax
```C#
public struct S1 {
    public int P1 { get; set; } // auto-implemented with hidden backing field
    public int P2 { get; }      // read-only auto property
}
```
### Example 2 – Expanded (what compiler does internally)
```C#
public struct S2 {
    private int _backing_field_p1;
    private readonly int _backing_field_p2;

    public int P1 {
        get { return _backing_field_p1; }
        set { _backing_field_p1 = value; }
    }

    public int P2 {
        get { return _backing_field_p2; }
    }
}
```
#### Usage:
```C#
S1 s1 = new S1();
s1.P1 = 10;  // calls s1.set_P1(10)
int val = s1.P1; // calls s1.get_P1()
```
### Notes:
- Auto-implemented properties hide the **private backing field**.
- They’re common for clean, simple data classes.

___
## Property vs Field

|Aspect|Field|Property|
|---|---|---|
|Declaration|`public int a;`|`public int A { get; set; }`|
|Access|Direct|Through getter/setter methods|
|Encapsulation|No control|Can add logic (validation, read-only, etc.)|
|Part of Interface|❌ Not visible in interfaces|✅ Can appear in interfaces|
|Backing|Direct memory|Often wraps a hidden field|
___
## Access Modifiers in Properties

You can define **different access levels** for `get` and `set`:
```C#
class B {
    public int P { get; set; }           // public read/write
    public int ReadOnlyP { get; }        // read-only property
    public int WriteOnlyP { private get; set; } // write-only outside class
    public int ControlledP { get; private set; } // read public, write private
}
```