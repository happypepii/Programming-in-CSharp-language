## Recap & Deeper Look at Member Hiding (`new` keyword)
### Classic scenario (Behavior changes unexpectedly)
```csharp
class A { public void F() { /* Alpha */ } }

class B : A { public void F() { /* Beta */ } } // hides A.F()
```
- When you call b.F() → **Beta** is executed.
- Old code that expected **Alpha** now silently gets **Beta** → dangerous!
- Compiler emits **warning** ("hides inherited member").
- Fix: add new → public new void F() → warning disappears (you explicitly acknowledge hiding).
### Why warning instead of Error?
**Version 1 of a 3rd-party library (NuGet package):**
```csharp
class A { }   // no F() method at all
```
**Your code (perfectly correct at that time):**
```csharp
class B : A
{
    public void F() { /* Your custom Beta implementation */ }
}
```
- No hiding → no warning → everything works perfectly.

>**Users worldwide keep asking library authors:** "Please add F() to A – we all implement it ourselves!"

**Version 2 of the library (adds the requested feature):**
```csharp
class A { public void F() { /* Alpha – generic implementation */ } }
```

| Situation               | Without `new` in B.F()          | Without `new` in B.F()          |
| ----------------------- | ------------------------------- | ------------------------------- |
| Compilation             | Warning CS0108                  | No warning                      |
| Runtime behavior        | Still calls your Beta (correct) | Still calls your Beta (correct) |
| If it would be an error | You couldn't compile at all     | __                              |

#### Why It MUST Stay a Warning (Not an Error)

Real-life situation:
- Library v1 has a **critical bug** (crash, security issue).
- Library v2 **fixes the bug** + as a side-effect adds the popular F() method.
- You urgently need the bug-fix for your customers.
If hiding were a **compilation error**:
- Your perfectly correct code would suddenly **fail to compile**.
- You are blocked from deploying the fixed library until you add new (or change logic) in possibly hundreds of places.
- → **Non-breaking helpful addition becomes a forced breaking change**.

**Conclusion:** Making member hiding an error would be a **show-stopper** for library evolution. The warning is the perfect compromise:
- Alerts you that the base class now has F().
- Lets you immediately use the bug-fix version.
- Gives you time later to decide: keep your version (new) or switch to the library’s version.

**Best practice**
```csharp
public new void F() { ... }   // explicitly document the hiding
```

## Virtual vs Non-Virtual Methods – Why Both Exist?
> “Java made everything virtual and the language is simpler. 
>  Why did C# (and C++) keep this complicated difference between normal methods and virtual methods?”

### Step-by-Step Performance Explanation
#### 1. What does the C# compiler actually emit?
```csharp 
class A { 
	public void M() { … } // non-virtual 
	public virtual void V() { … } // virtual }
```

| Method type    | IL instruction generated by C# compiler | What it means                                 |
| -------------- | --------------------------------------- | --------------------------------------------- |
| Normal method  | `call void A::M()`                      | “Call this exact method – I know where it is” |
| Virtual method | `callvirt void A::V()`                  | “Do late binding – look it up at runtime”     |
Important: Even if you call it on a variable of exact type A, the compiler still emits `callvirt` for virtual methods.
#### 2. What does the JIT do with these two IL instructions?

| IL instruction | How JIT compiles it to real machine code                                  | Cost                      |
| -------------- | ------------------------------------------------------------------------- | ------------------------- |
| `call`         | Direct jump → the actual memory address is written directly into the code | 1 memory read + 1 jump    |
| `callvirt`     | Indirect jump → must read the v-table first                               | 3–5 memory reads + 1 jump |
Detailed steps for `callvirt`:
1. Load "this" pointer from stack
2. Read the "sync block" / object header → get pointer to MethodTable (type info)
3. From MethodTable, read pointer to virtual method table (v-table)
4. From v-table, read the correct slot (fixed index for this method)
5. Jump to the address found in that slot
→ 4–5 dependent memory reads before we even jump!
#### 3. So virtual calls should always be slower… right?
That’s what everyone thinks, but BenchmarkDotNet proves otherwise
### Answer 1: Performance (but it’s nuanced)
`call` directly put the address of the function while
`callvirt` needs to decide it in runtime so non-virtual function do better in performance

| Call type                       | JIT generates                      | Typical cost (very short method) |
| ------------------------------- | ---------------------------------- | -------------------------------- |
| Non-virtual + inlined           | Direct code copy (no call)         | ~0 ns (baseline)                 |
| Non-virtual (not inlined)       | Direct call (fixed address)        | ~1–2 ns                          |
| Virtual (normal v-table lookup) | Indirect call via v-table          | ~2–4 ns                          |
| Virtual (after Dynamic PGO)     | Can be **devirtualized + inlined** | Can be as fast as non-virtual!   |
Key modern .NET features (since .NET Core / .NET 8/9):

- **Tiered compilation** (Tier 0 → Tier 1) [[(Supplement) Tiered Compilation]]
- **Dynamic PGO** (Profile-Guided Optimization) – JIT collects runtime statistics:
    - How many times a method is called
    - What concrete types are most frequently seen in a variable of base type
- If JIT sees that a variable of type A is **almost always** a C, it generates a **hot path**:
  ```csharp
	Hot path (executed 99.9% of time):
    fast type check → "is it still C?"
    if yes → direct call to C.V() + inline the body!   ← devirtualized + inlined

	Cold path (rare):
	    full normal virtual dispatch
  ```
**Benchmark results shown in lecture (simplified):**

| Scenario                             | Approx. time per call             |
| ------------------------------------ | --------------------------------- |
| Non-virtual + inlined                | ~0 ns (measurement noise)         |
| Non-virtual, forced no-inline        | ~2–3 ns                           |
| Virtual (stable type → PGO kicks in) | ~0–1 ns (devirtualized + inlined) |
| Virtual (type constantly flipping)   | ~4–5 ns (full v-table dispatch)   |
**Takeaway on performance:**
- Raw virtual call overhead is tiny (~1–3 ns).
- Inlining is the **real** performance win.
- Non-virtual methods → inlining almost always possible.
- Virtual methods → inlining possible only when PGO statistics allow devirtualization.
- → By default, **non-virtual gives you more predictable fast code**.
**Don’t prematurely make everything non-virtual for speed** – the difference is negligible unless you call the method billions of times and it’s tiny.

### Answer 2: Extensibility & Design Intent (the more important reason)
|                          | Non-virtual method                                                       | Virtual method                                              |
| ------------------------ | ------------------------------------------------------------------------ | ----------------------------------------------------------- |
| Contract with inheritors | “This behavior is final – don’t change it”                               | “This behavior is designed to be overridden”                |
| Library evolution        | You can safely add new overloads / change implementation (within reason) | Changing base implementation can break many derived classes |
| Versioning               | Much safer for library authors                                           | Riskier – derived classes may depend on exact old behavior  |
Example (library author perspective):
```csharp
class Widget
{
    public void Draw() { … }           // non-virtual → library promises stable behavior
    public virtual void OnClick() { }  // expected to be overridden
}
```
If Draw() were virtual, a library update that improves the default drawing could unintentionally break hundreds of derived classes that overrode it with custom logic.

**Conclusion on design:**
- **Non-virtual** = “This is the correct, stable behavior”
- **Virtual** = “Polymorphism is part of the design here”

### Answer 3: Precise Control Over the Extensibility Chain(the `sealed` keyword)
C# lets you open and close extensibility exactly where you want:

|Keyword combination|Meaning for descendants|Example|
|---|---|---|
|`virtual`|Opens extensibility for everyone below|`public virtual void Save()`|
|`override`|Keeps it open (descendants may override again)|`public override void Save()`|
|`sealed override`|Closes it – no further overrides allowed|`public sealed override void Save()`|
|`sealed class`|No one may inherit from this class at all|`public sealed class StringBuilder`|
Bonus side-effect (he mentioned only in passing): sealed override → JIT can devirtualise the call 100 % of the time, even on a base-type variable.

Takeaway: C# gives you **fine-grained control** that Java simply does not have. You are never forced to keep a method extensible forever just because it once was.

## Summary – Why C# Keeps Both Virtual and Non-Virtual
| Reason                 | Non-Virtual Wins                            | Virtual Wins                       |
| ---------------------- | ------------------------------------------- | ---------------------------------- |
| Performance            | More predictable inlining → slightly faster | Can be just as fast with PGO       |
| Predictability         | Guaranteed fast path                        | Depends on runtime type statistics |
| Extensibility / Safety | Library can evolve implementation safely    | Designed for polymorphic use       |
| Intent communication   | Clear message: “don’t override”             | Clear message: “override me”       |

|                          | Non-Virtual                      | Virtual                                   |
| ------------------------ | -------------------------------- | ----------------------------------------- |
| Default in C#            | Yes                              | Only when you write the word `virtual`    |
| Inlining chance          | Almost always                    | Only when JIT can prove the concrete type |
| Performance (worst case) | Fast                             | Slightly slower                           |
| Library author freedom   | Can change implementation safely | Very careful – many people may override   |
| Message to the reader    | “This behavior is final”         | “You are expected to override this”       |

| Reason for non-virtual by default | C# (what we get)                               | Java (what we lose)                         |
| --------------------------------- | ---------------------------------------------- | ------------------------------------------- |
| 1. Predictable performance        | Slightly faster + always inlinable             | Tiny overhead (usually disappears anyway)   |
| 2. Safe library evolution         | Library author can refactor internals freely   | Fragile base-class problem everywhere       |
| 3. Precise extensibility control  | `virtual` / `override` / `sealed` – you decide | Everything is always open → no way to close |

**Rule of thumb (exactly what the lecturer recommends):**
- Make a method **non-virtual by default**.
- Only make it **virtual** (or abstract) when polymorphism is part of the intended design.
- Never choose based only on micro-benchmarks unless you have proven hot spots.

>  “Non-virtual by default + explicit virtual + sealed = the most important object-oriented design feature that Java is still missing today.”