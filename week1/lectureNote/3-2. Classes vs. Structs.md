This program demonstrates the core difference between **`class` (reference types)** and **`struct` (value types)** in C#.  
The key idea: **how they behave when passed to methods**.
```C#
using System;

namespace ClassesVsStructs
{
    class C
    {
        public int x;
    }

    struct S
    {
        public int y;
    }

    class Program
    {
        static void Main(string[] args)
        {
            C c1 = new C();
            c1.x = 10;

            S s1 = new S();
            s1.y = 100;

            Console.WriteLine("Main before f call: c1.x == {0}, s1.y =={1}", c1.x, s1.y);
            f(c1, s1);
            Console.WriteLine("Main after f call: c1.x == {0}, s1.y =={1}", c1.x, s1.y);

            Console.WriteLine();
            Console.WriteLine(c1);
            Console.WriteLine(s1);
        }

        static void f(C c2, S s2)
        {
            Console.WriteLine("f starts: c2.x == {0}, s2.y =={1}", c2.x, s2.y);
            c2.x = 20;
            s2.y = 200;
            Console.WriteLine("f before g calls: c2.x == {0}, s2.y =={1}", c2.x, s2.y);
            g(c2, s2);
            Console.WriteLine("f ends: c2.x == {0}, s2.y =={1}", c2.x, s2.y);
        }

        static void g(C c3, S s3)
        {
            Console.WriteLine("g starts: c3.x == {0}, s3.y =={1}", c3.x, s3.y);
            c3.x = 30;
            s3.y = 300;
            Console.WriteLine("g ends: c3.x == {0}, s3.y == {1}", c3.x, s3.y);
        }
    }
}

```


## Core Concepts

|Type|Category|Memory Location|Passed To Methods As|Common Use|
|---|---|---|---|---|
|`class`|**Reference Type**|**Heap**|**By reference** (changes affect the original)|Complex data models, entities|
|`struct`|**Value Type**|**Stack**|**By value** (copy, no effect on original)|Small lightweight data, coordinates, colors|

## Step-by-Step Behavior
### In `Main()`
```C#
C c1 = new C();  // reference type, stored on heap
c1.x = 10;

S s1 = new S();  // value type, stored on stack
s1.y = 100;
```

Then we call:
```C#
f(c1, s1);
```
- `c1` → passed by reference
- `s1` → passed by value (**copied**)

### Inside `f()`

At the start:

```C#
c2.x == 10, s2.y == 100
```

Modify values:
```C#
c2.x = 20;   // affects the same object as c1 
s2.y = 200;  // affects only the local copy
```

Then call `g(c2, s2)`.

### Inside `g()`
At the start:

```C#
c3.x == 20, s3.y == 200`
```

Modify again:

```C#
c3.x = 30;  // same reference — affects c1 
s3.y = 300; // local copy only
```

When returning:
- `c1.x` is now **30**
- `s1.y` is still **100**

---
```css
Main before f call: c1.x == 10, s1.y ==100
f starts:           c2.x == 10, s2.y ==100
f before g calls:   c2.x == 20, s2.y ==200
g starts:           c3.x == 20, s3.y ==200
g ends:             c3.x == 30, s3.y ==300
f ends:             c2.x == 30, s2.y ==200
Main after f call:  c1.x == 30, s1.y ==100

ClassesVsStructs.C
ClassesVsStructs.S
```

## Key Takeaways

- ✅ **Class = reference type** → method changes persist after returning.
- ✅ **Struct = value type** → method changes don’t affect the original.
- ⚙️ `new` for a **struct** allocates it on the stack (no heap allocation).
- ⚙️ `new` for a **class** allocates it on the heap and returns a reference.