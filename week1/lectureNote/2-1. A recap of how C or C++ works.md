- every variable is a value
- structure = class

## How C/C++ works?
Let’s look at what really happens when we execute:
```c
int a = 10;
int b = 5;
int c = a + b;
```

### Step 1. **Variable declaration and initialization**
- `int a = 10;`
    - The compiler allocates **4 bytes** on the **stack** for variable `a`.
    - The value `10` is stored **directly** in that memory(e.g., at `rbp-12`).
- `int b = 5;`
    - Another 4 bytes are allocated (e.g., at `rbp-8`).
    - The value `5` is stored there.

```css
Stack memory (high → low)
┌───────────────┐
│ a (rbp-12):10 │  ← 4 bytes
│───────────────│
│ b (rbp-8): 5  │  ← 4 bytes
└───────────────┘
```

### Step 2. Expression evaluation
When the CPU executes:
```c
int c = a + b;
```

It does the following at a low level:
1. **Reads** the value stored in `a` (10)
2. **Reads** the value stored in `b` (5)
3. **Performs addition** in the CPU’s ALU (Arithmetic Logic Unit):  
    `10 + 5 = 15`
4. **Allocates** another 4 bytes on the stack for variable `c` (e.g., `rbp-4`)
5. **Stores** the result `15` directly into that memory

### Step 3. Final memory state
```css
Stack memory
┌───────────────┐
│ a: 10         │
│───────────────│
│ b: 5          │
│───────────────│
│ c: 15         │
└───────────────┘
```
- Each variable is an **independent memory cell** on the stack.
- The compiler knows each variable’s address using offsets from `rbp`.
- Local variables disappear when the function returns.
- There are **no objects or references** here — just raw data.  
    This makes C arithmetic operations **much faster** than in Python,  
    where every variable is a **reference to a heap-allocated object**.



## How struct/class works in C/C++
### Basic idea

- A **`struct`** (or **`class`**) is a **custom data type** that groups several variables (called _members_) together.
- Each instance (object) of that struct/class occupies a **contiguous block of memory**.
Example:
```c
struct Point {
    int x;
    int y;
};
```

When you create:
```c
Point p; 
p.x = 3; 
p.y = 7;
```
#### Memory layout
```css
Stack memory
┌───────────────────┐
│ p.y = 7           │  ← 4 bytes
│ p.x = 3           │  ← 4 bytes
└───────────────────┘
```
- Total = 8 bytes  
- `p` itself is **the actual data**, not a reference.  
- Accessing `p.x` just means “go to the memory offset for `x`”.

#### Access pattern
When you write:
```c
int value = p.x;
```
The compiler translates it to:
- Compute address of `p` (e.g. `rbp - 8`)
- Add offset for `x` (0)
- Read 4 bytes from that location → store in register
It’s **purely arithmetic on addresses** — no heap, no reference, no object header.

 
 ## [[2-2. Stack vs Heap — When each is used]]
[[1.  A recap of how Python works]]
[[3-1. Finally, how C sharp works]]
