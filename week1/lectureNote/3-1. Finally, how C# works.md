# C# vs .NET

| Item                | Description                                                                                            |
| ------------------- | ------------------------------------------------------------------------------------------------------ |
| **.NET**            | The **runtime environment** and **standard library**                                                   |
| **C#**              | The **programming language**                                                                           |
| **Other languages** | .NET can also serve as the runtime environment for other languages such as **Visual Basic** and **F#** |

---

# Type Systems in C#

Every type in C# falls into one of two categories:
- **Value Type**
- **Reference Type**

##  1. Value Type

📍 **Memory allocation:** Stored **in-place** (typically on the stack, with exceptions).
### Includes:
- **Enums**
- **Structures (`struct`)**
  - **Simple types**
    - `int32`
    - `int64`
    - `double`
    - `bool`
    - `char`
    - ...
  - **User-defined structures**
  - **`Nullable<T>`**, where `T` is any value type

##  2. Reference Type

📍 **Memory allocation:** Stored in the **managed heap** (controlled by the garbage collector).
### Includes:
- `class`
- `interface`
- `array`
- `delegate`
---

## Garbage Collector heap
```C#
class C {
    public int x;
    public string z;
}

C c1 = new C();
```

### Heap - Memory layout 
```css

┌──────────────────────────────────┐
│ - Sync block                     │
│ - Object overhead                │
│ - Data (value type)              │  ← e.g., x (int)
│ - Data (reference type → points elsewhere) │  ← e.g., z (string)
└──────────────────────────────────┘
```

### Stack 
```css
┌───────────────┐.   ┌──────────────────────────────────┐
│ c1 ───────────┼──▶ │ - Object overhead                │
└───────────────┘	 │ - Sync block.                    │
                     │ - Data (value type)              │
                     │ - Data (reference type → points elsewhere) │
                     └──────────────────────────────────┘
```


# `new()` on Reference Types vs Value Types

## Reference Type

### Example
```csharp
class C {
    public int x;
}

C c1 = new C();

```

### What happens
- `new C()` allocates memory on the managed heap for the object.
- The variable `c1` (on the stack) stores a reference (pointer) to that heap object.
- The constructor (if any) runs after allocation to initialize fields.
- The Garbage Collector (GC) manages the object’s lifetime.
📍 Key idea:
Using new with a reference type always allocates a new object on the GC heap.
```css
Stack                           Heap (Managed by GC)
┌────────────┐                  ┌────────────────────────────┐
│ c1 ────────┼────────────────▶ │ Object C                   │
└────────────┘                  │ - Sync block               │
                                │ - Object overhead          │
                                │ - x = 0 (initialized)      │
                                └────────────────────────────┘
```

## Value Type

### Example

```c#
struct S {    
	public int x; 
}  
S s1 = new S();
```
### What happens
- `new S()` **does NOT allocate on the heap** (unless boxed or part of a reference type).
- Memory for `s1` is usually allocated **in-place** (e.g., on the stack or inside another object).
- The `new` keyword **initializes** all fields to their default values (e.g., `0`, `false`, `null` for refs).
- For structs, you can create them **without `new`**, but then **you must manually assign all fields** before using them.
📍 **Key idea:**  
Using `new` with a value type **initializes**, but **does not allocate** on the GC heap.
```css
Stack
┌────────────────────────────┐
│ s1                         │
│ ├─ x = 0 (initialized)     │
└────────────────────────────┘
```