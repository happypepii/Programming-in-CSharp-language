# C# vs .NET

| Item                | Description                                                                                            |
| ------------------- | ------------------------------------------------------------------------------------------------------ |
| **.NET**            | The **runtime environment** and **standard library**                                                   |
| **C#**              | The **programming language**                                                                           |
| **Other languages** | .NET can also serve as the runtime environment for other languages such as **Visual Basic** and **F#** |

---

# Type Systems in C#

Every type in C# falls into one of two categories:
- **Value Type**
- **Reference Type**

##  1. Value Type

ğŸ“ **Memory allocation:** Stored **in-place** (typically on the stack, with exceptions).
### Includes:
- **Enums**
- **Structures (`struct`)**
  - **Simple types**
    - `int32`
    - `int64`
    - `double`
    - `bool`
    - `char`
    - ...
  - **User-defined structures**
  - **`Nullable<T>`**, where `T` is any value type

##  2. Reference Type

ğŸ“ **Memory allocation:** Stored in the **managed heap** (controlled by the garbage collector).
### Includes:
- `class`
- `interface`
- `array`
- `delegate`
---

## Garbage Collector heap
```C#
class C {
    public int x;
    public string z;
}

C c1 = new C();
```

### Heap - Memory layout 
```css

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ - Sync block                     â”‚
â”‚ - Object overhead                â”‚
â”‚ - Data (value type)              â”‚  â† e.g., x (int)
â”‚ - Data (reference type â†’ points elsewhere) â”‚  â† e.g., z (string)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Stack 
```css
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”.   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ c1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â–¶ â”‚ - Object overhead                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜	 â”‚ - Sync block.                    â”‚
                     â”‚ - Data (value type)              â”‚
                     â”‚ - Data (reference type â†’ points elsewhere) â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


# `new()` on Reference Types vs Value Types

## Reference Type

### Example
```csharp
class C {
    public int x;
}

C c1 = new C();

```

### What happens
- `new C()` allocates memory on the managed heap for the object.
- The variable `c1` (on the stack) stores a reference (pointer) to that heap object.
- The constructor (if any) runs after allocation to initialize fields.
- The Garbage Collector (GC) manages the objectâ€™s lifetime.
ğŸ“ Key idea:
Using new with a reference type always allocates a new object on the GC heap.
```css
Stack                           Heap (Managed by GC)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ c1 â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Object C                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚ - Sync block               â”‚
                                â”‚ - Object overhead          â”‚
                                â”‚ - x = 0 (initialized)      â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Value Type

### Example

```c#
struct S {    
	public int x; 
}  
S s1 = new S();
```
### What happens
- `new S()` **does NOT allocate on the heap** (unless boxed or part of a reference type).
- Memory for `s1` is usually allocated **in-place** (e.g., on the stack or inside another object).
- The `new` keyword **initializes** all fields to their default values (e.g., `0`, `false`, `null` for refs).
- For structs, you can create them **without `new`**, but then **you must manually assign all fields** before using them.
ğŸ“ **Key idea:**  
Using `new` with a value type **initializes**, but **does not allocate** on the GC heap.
```css
Stack
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ s1                         â”‚
â”‚ â”œâ”€ x = 0 (initialized)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```